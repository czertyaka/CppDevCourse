\documentclass[14pt]{extarticle}

\usepackage{homeworktemplate}
\usepackage[askip=3mm, bskip=3mm]{terminal}
\usepackage[askip=3mm, bskip=3mm]{mylisting}
\usepackage{tcolorbox}
\usepackage{csquotes}

\title{Домашняя работа 5 \\ Hide Secret}

\begin{document}

\maketitle

\tableofcontents

\section{Описание задания}

    \subsection{Проблема}
    
    В этом домашнем задании вам предлагается решить следующую проблему:

    \begin{tcolorbox}[title=Проблема]

        Имея заданный \textit{открытый текст}, найти в нём все вхождения известного
        \textit{секретного текста}, и заменить его на строки той же длины, состоящие
        из символа \texttt{x}.
        
    \end{tcolorbox}

    Пример работы программы, решающей эту проблему:

    \begin{terminalwindow}
!\shellcommand{./build/main "My silly password is '12345678'" "12345678"}!
My silly password is 'xxxxxx'
    \end{terminalwindow}

    \subsection{Шаблон проекта}
    
        Для выполнения задания подготовлен проект C++ с настроенной системой сборки,
        написанными тестами и частью кода такой программы.
        GitHub проекта: \url{https://github.com/czertyaka/CppDevCourse-hw-hide-secret}.

        В этом шаблоне проекта уже написана функция \texttt{main}, обрабатывающая
        пользовательский ввод: \textit{открытый текст} и \textit{секретный текст}.
        После валидации ввода функция передает управление вместе с входными данными
        функции \texttt{hide\_secret}.
        За вывод результата обработки \textit{открытого текста} так же отвечает
        функция \texttt{main}.
        В \textit{main.cpp} в рамках домашнего задания ничего менять не нужно.

        В файле \textit{hide-secret.hpp} содержится объявление функции \\ \texttt{hide\_secret}:

        \myinputlisting[minted language=cpp]
            {Homeworks/05-Hide-Secret/hw-project/}
            {hide-secret.hpp}

        В домашнем задании вам необходимо добавить файл \textit{hide-secret.cpp} в корень
        проекта с определением этой функции.

        В файле \textit{README.md} содержатся инструкции по сборке проекта после добавления
        \textit{hide-secret.cpp}.

    \subsection{Описание входных данных}

        Функция \texttt{hide\_secret} имеет два параметра:

        \begin{enumerate}

            \item \texttt{text} \textemdash \space указатель на массив символов
                \textit{открытого текста}.
                Массив мутабельный, функция имеет возможность менять его содержимое.
                Указатель иммутабельный, функция не может менять этот параметр.

            \item \texttt{secret} \textemdash \space указатель на массив символов
                \textit{секретного текста}.
                Функция не может менять его содержимое и сам параметр.

        \end{enumerate}
        
        Гарантировано, что массивы текстов имеют конечную длину (очевидно) и что
        последним символом каждого массива является null-terminator \verb|\0|.

    \subsection{Замечания по реализации функции} \label{stdstring}

        Для программистов, знакомых с классами из стандартной библиотеки C++,
        не составит труда написать решение задания, используя класс \texttt{std::string}.

        В качестве основы для решения можно было бы взять такой код:

        \begin{myinplacelisting}[minted language=cpp]
std::string text {"My silly password is '12345678'"};
std::string_view secret {"12345678"};

const auto pos = text.find(secret);
if (pos == std::string::npos) {
    return;
}

text.replace(pos, secret.size(), secret.size(), 'x');
        \end{myinplacelisting}

        В большинстве реальных проектов это было бы абсолютно верным решением.
        С точки зрения поддержки и читаемости такой код значительно проще
        \enquote{магии} с сырыми указателями.
        Однако в этой домашней работе вам предлагается поупражняться
        именно в такой \enquote{магии}.
        Понимание принципов, лежащих в основе реализации более высоких уровней
        абстракции, полезно. 

        Также стоит добавить, что приведенное выше решение не универсально
        и имеет недостатки.
        Самый большой из них \textemdash \space оно не очень эффективно.
        Для манипуляций с \textit{открытым текстом} в нем создается объект
        \texttt{textStr} с типом \texttt{std::string}.
        Этот объект скопирует в свою память содержимое \texttt{text}.
        При этом, если окажется, что размер \textit{открытого текста} слишком
        велик, то для этого будет выделена память в куче.
        Это выделение при некоторых условиях может оказаться затратной по времени
        операцией.
        Код, написанный на сырых указателях, может избежать ненужного копирования
        и потенциальной аллокации памяти в куче, что позволит ему работать быстрее.

    \subsection{Требования} \label{requirements}

        \begin{enumerate}

            \item Функция должна заменить \textit{секретный текст} на последовательность
                симолов \verb|x| в массиве, на который указыват параметр \texttt{text}.

            \item Длина последовательности \verb|x| должна быть равной длине
                \textit{секретного текста}.
                Т.е. \verb|123| \rightarrow \space \verb|xxx|, и \verb|12345|
                \rightarrow \space \verb|xxxxx|.

            \item Если в \textit{открытом тексте} содержится несколько вхождений
                \textit{секретного текста}, то заменены должны быть все вхождения:
                \verb|123 + 123| \rightarrow \space \verb|xxx + xxx|.

            \item Функция \texttt{hide\_secret} не должна содержать неопределенного
                поведения или приводить к нештатному завершению работы программы.

            \item Функция не должна выполнять ненужных аллокаций и копирования
                текстов (см. \ref{stdstring}).

        \end{enumerate}

\section{Порядок выполнения}

    \begin{enumerate}

        \item Создайте форк репозитория \url{https://github.com/czertyaka/CppDevCourse-hw-hide-secret}.

        \item Добавьте в форк файл \textit{hide-secret.cpp} c реализацией функции \texttt{hide\_secret}.

        \item Соберите проект и протестируйте решение (если получилось установить зависимости,
            необходимые для тестирования).
            Этот пункт не обязателен, потому что в pull request эти же тесты будут выполнены
            в рамках GitHub Actions.

        \item Создайте pull request из вашего форка в оригинальный репозиторий,
            в названии которого есть ваше ФИО.

    \end{enumerate}

\section{Критерии выполнения}

    \begin{itemize}

        \item Выполнены все требования из \ref{requirements}.

        \item Pull request проходит автоматизированные проверки.

        \item Код в pull request прошел ревью преподавателем.

    \end{itemize}

\end{document}

