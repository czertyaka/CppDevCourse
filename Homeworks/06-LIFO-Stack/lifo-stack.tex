\documentclass[14pt]{extarticle}

\usepackage{homeworktemplate}
\usepackage[askip=3mm, bskip=3mm]{terminal}
\usepackage[askip=3mm, bskip=3mm]{mylisting}
\usepackage{tcolorbox}
\usepackage{csquotes}

\title{Домашняя работа 6 \\ LIFO Stack}

\begin{document}

\maketitle

\tableofcontents

\section{Описание задания}

    \subsection{Проблема}
    
        В этом домашнем задании вам предлагается разработать библиотеку,
        реализующую примитивный вариант структуры данных \textit{стек LIFO}\footnotemark{}.

        \footnotetext{\url{https://ru.wikipedia.org/wiki/LIFO}}
    
        Библиотека позволит создавать несколько \enquote{контейнеров}-стеков и
        управлять временем их жизни.

        Пользователь библиотеки работает с разными объектами стеков через
        уникальный идентификатор с типом \texttt{Handle}.
        Такой подход очень распространен в тех случаях, когда работа с объектами
        и их типами напрямую нежелателен.
        Он является идеологическим преемником другого подхода, который называется
        \textit{opaque pointer}\footnotemark{}.

        \footnotetext{\url{https://ru.wikipedia.org/wiki/Opaque\_pointer}}

        Библиотека не будет хранить информацию о типе данных, передаваемых в
        стек.
        Это позволит пользователю библиотеки хранить в одном стеке данные разных
        типов, но и обязует его помнить тип данных.

    \subsection{Шаблон проекта}
    
        Для выполнения задания подготовлен проект C++ с настроенной системой сборки,
        написанными тестами и частью кода такой программы.
        GitHub проекта: \url{https://github.com/czertyaka/CppDevCourse-hw-lifo-stack}.

        В шаблоне написан заголовочной файл библиотеки с объявлениями
        ее функций.

        \myinputlisting[minted language=cpp]
            {Homeworks/06-LIFO-Stack/hw-project/}
            {stack.hpp}

        Все функции объявлены в пространстве имен \texttt{stack}.
        Набор этих функций является API разрабатываемой библиотеки.

        Определения этих функций также уже имеются в шаблоне проекта
        в файле \textit{stack.cpp}.
        В этих определениях нет никакой полезной функциональности.
        По своей сути они являются \enquote{заглушками}, нужными лишь затем,
        чтобы проект можно было скомпилировать.

        В этом домашнем задании нужно вместо этих \enquote{заглушек} написать
        определения, удовлетворяющие требованиям из следующего подраздела.

    \subsection{Требования к функциям библиотеки} \label{requirements}

        \begin{itemize}

            \item \verb|Handle create()|

                \textbf{Описание}: Создать новый стек.

                \textbf{Возвращаемое значение}: \texttt{-1} в случае ошибки выполнения,
                хэндлер нового стека с неотрицательным значением в случае успеха.

            \item \verb|void destroy(const Handle handle)|

                \textbf{Описание}: Удалить стек, если соответствующий хэндлеру
                стек существует.

                \textbf{Параметры}: \texttt{handle} \textemdash \space хэндлер стека.

            \item \verb|bool valid(const Handle handle)|

                \textbf{Описание}: Проверить хэндлер.

                \textbf{Параметры}: \texttt{handle} \textemdash \space хэндлер стека.

                \textbf{Возвращаемое значение}: \texttt{true} - соответствующий
                хэндлеру стек существует, \texttt{false} - нет.

            \item \verb|std::size_t count(const Handle handle)|

                \textbf{Описание}: Получить количество элементов в стеке, если
                соответствующий хэндлеру стек существует.

                \textbf{Параметры}: \texttt{handle} \textemdash \space хэндлер стека.

                \textbf{Возвращаемое значение}: количество элементов в стеке, если
                соответствующий хэндлеру стек существует, \texttt{0} в противном случае.

            \item \verb|void push(const Handle handle, const void* const data,| \break
                \verb|const std::size_t size)|

                \textbf{Описание}: Добавить элемент данных из буфера в стек, если
                соответствующий хэндлеру стек существует.

                \textbf{Параметры}: \texttt{handle} \textemdash \space хэндлер стека; \hfill \break
                \texttt{data} \textemdash \space указатель на буфер с данными; \hfill \break
                \texttt{size} \textemdash \space размер буфера с данными.

            \item \verb|std::size_t pop(const Handle handle, void* const data,| \break
                \verb|const std::size_t size)|

                \textbf{Описание}: Извлечь элемент из стека и записать данные этого элемента
                в буфер, если соответствующий хэндлеру стек существует и его размер не равен
                \texttt{0}.

                \textbf{Параметры}: \texttt{handle} \textemdash \space хэндлер стека; \hfill \break
                \texttt{data} \textemdash \space указатель на буфер для записи данных; \hfill \break
                \texttt{size} \textemdash \space размер буфера для записи.

                \textbf{Возвращаемое значение}: размер записанных данных в байтах, если
                соответствующий хэндлеру стек существует и его размер не равен \texttt{0},
                \texttt{0} в противном случае.
            
        \end{itemize}

\section{Порядок выполнения}

    \begin{enumerate}

        \item Создайте форк репозитория \url{https://github.com/czertyaka/CppDevCourse-hw-lifo-stack}.

        \item Измените в форке файл \textit{stack.cpp}.

        \item Соберите проект и протестируйте решение (если получилось установить зависимости,
            необходимые для тестирования).
            Этот пункт не обязателен, потому что в pull request эти же тесты будут выполнены
            в рамках GitHub Actions.

        \item Создайте pull request из вашего форка в оригинальный репозиторий,
            в названии которого есть ваше ФИО.

    \end{enumerate}

\section{Критерии выполнения}

    \begin{itemize}

        \item Выполнены все требования из \ref{requirements}.

        \item Pull request проходит автоматизированные проверки.

        \item Код в pull request прошел ревью преподавателем.

    \end{itemize}

\end{document}

